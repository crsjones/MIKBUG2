*
*********************
*
* POSTIVE DIVIDE -----
*
*   THIS ROUTINE DIVIDES THE 16 BIT POSITIVE DIVIDEND
*   IN THE A:B REGISTERS (A IS THE MSB) BY AN 8
*   BIT POSITIVE  DIVISOR POINTED TO BY THE X-REGISTER.
*   THE QUOTIENT IS IN B ON EXIT AND THE REMAINDER
*   IS IN THE A-REGISTER. THE X-REGISTER IS
*   DESTROYED.
*   IF DIVISION BY ZERO WAS ATTEMPTED OR THE
*   QUOTIENT WILL NOT FIT IN 8 BITS THE OVERFLOW
*   BIT IS SET ON EXIT. ALSO V IS SET IF EITHER
*   THE DIVIDEND OR THE DIVISOR IS NEGATIVE ON CALL.
*   OTHERWISE V IS CLEARED.
*
*
*   THE ROUTING IS PURE,RE-ENTRANT AND POSITION INDEPENDENT.
*
*   DURING EXECUTION THE STACK CONTAINS
*   0,X  =  LOOP COUNTER
*   1,X  =  DIVISOR
*   2,X  =  DIVIDEND MSB (ONLY USED FOR TEMP STORE)
*
*   THE METHOD USED IS NON RESTORING DIVIDE WHERE THE
*   DIVIDEND AND DIVISOR AND KNOWN TO BE POSITIVE. THIS
*   METHOD PROVED FASTEST SINCE IT CAN BE CARRIED OUT
*   ESSENTIALLY IN THE ACCUMULATORS. THE ALGORITHM TRIES
*   TO GET THE REMAINDER AS NEAR ZERO AS POSSIBLE
*   AND SOMETIMES ADDS THE DIVISOR AND SOMETIMES
*   SUBTRACTS IT DEPENDING ON WHICH SIDE OF ZERO THE
*   PARTIAL REMAINDER RESIDES AT ANY TIME. FOR MORE
*   INFO READ: 'AN ALGORITHM FOR NON RESTORING DIVISION'
*   S. SANYAL ; 'COMPUTER DESIGN' / MAY 1977.
*
*   EXECUTION TIME AVERAGE (NO OVERFLOWS): 289 CYCLES
*     THIS TIME IS RELATIVELY INDEPENDENT OF THE
*     CALLING VALUES.
*
*
*********************
*
DIV    PSHA            SAVE DIVIDEND MSB A SECOND
       LDAA   0,X      FETCH THE DIVISOR
       BMI    DIVOV2   NEGATIVE DIVISOR IS A NO-NO
       PSHA            PUSH IT
       LDAA   #8       PUSH LOOP CTR
       PSHA
       TSX             POINT X TO STACK
       LDAA   2,X      RESTORE ORIGINAL DIVIDEND MSB
       CMPA   1,X      WILL QUOTIENT OVERFLOW? (ALS D!
       BCC    DIVOVF   YES,GO SET V AND EXIT
DLOOP  ASLB            SHIFT DIVIDEND-ANSWER LEFT
       ROLA
       BCC    DL2      IS DIVIDEND MS BIT SET?
       ADDA   1,X      YES,ADD DIVISOR TO MSB
